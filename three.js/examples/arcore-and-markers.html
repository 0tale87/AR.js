<!DOCTYPE html>
<html lang="en">
<head>
        <title>three.ar.js - Boilerplate</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no,
        minimum-scale=1.0, maximum-scale=1.0">
        <style>
        body {
                font-family: monospace;
                margin: 0;
                overflow: hidden;
                position: fixed;
                width: 100%;
                height: 100vh;
                -webkit-user-select: none;
                user-select: none;
        }
        #info {
                width: 100%;
                position: absolute;
                left: 50%;
                bottom: 0;
                transform: translate(-50%, 0)
                margin: 1em;
                z-index: 10;
                display: block;
                line-height: 2em;
                text-align: center;
        }
        #info * {
                color: #fff;
        }
        .title {
                background-color: rgba(40, 40, 40, 0.4)
                padding: 0.4em 0.6em;
                border-radius: 0.1em;
        }
        .links {
                background-color: rgba(40, 40, 40, 0.6)
                padding: 0.4em 0.6em;
                border-radius: 0.1em;
        }
        canvas {
                position: absolute;
                top: 0;
                left: 0;
        }
        </style>
</head>
<body>
        <div id="info">
                <span class="title">marker detection + arcore</span><br/>
                <span class="links">
                        <a href="https://github.com/jeromeetienne/ar.js">ar.js</a> -
                        <a href="..">examples</a>
                        <br/>
                        markerroot <span class='markerroot_status'>marker invisible</span>
                </span>
        </div>
        <script src="../vendor/three-ar.js/third_party/three.js/three.js"></script>
        <script src="../vendor/three-ar.js/third_party/three.js/VRControls.js"></script>
        <script src="../vendor/three-ar.js/third_party/three.js/OBJLoader.js"></script>
        <script src="../vendor/three-ar.js/third_party/three.js/MTLLoader.js"></script>
        <script src="../vendor/three-ar.js/dist/three.ar.js"></script>
        
        <!-- jsartookit -->
        <script src='../vendor/jsartoolkit5/build/artoolkit.min.js'></script>
        <script src='../vendor/jsartoolkit5/js/artoolkit.api.js'></script>
        <!-- include threex.artoolkit -->
        <script src='../src/threex/threex-artoolkitsource.js'></script>
        <script src='../src/threex/threex-artoolkitcontext.js'></script>
        <script src='../src/threex/threex-artoolkitprofile.js'></script>
        <script src='../src/threex/threex-arbasecontrols.js'></script>
        <script src='../src/threex/threex-armarkercontrols.js'></script>
        <script src='../src/threex/threex-arsmoothedcontrols.js'></script>
        <script>ARjs.Context.baseURL = '../'</script>
        
        <script>

	// array of functions for the rendering loop
	var onRenderFcts= [];
        var vrFrameData;

        var vrDisplay, vrControls, arView;
        var canvas, camera, scene, renderer;
        var BOX_DISTANCE = 1.5;
        var BOX_SIZE = 0.25;
        var BOX_QUANTITY = 6;
        var boxesAdded = false;
        
        /**
        * Use the `getARDisplay()` utility to leverage the WebVR API
        * to see if there are any AR-capable WebVR VRDisplays. Returns
        * a valid display if found. Otherwise, display the unsupported
        * browser message.
        */
        THREE.ARUtils.getARDisplay().then(function (display) {
                if (display) {
                        vrDisplay = display;
                        init()
                } else {
                        THREE.ARUtils.displayUnsupportedMessage()
                }
        })
        
        function init() {
                vrFrameData = new VRFrameData()

                // Setup the three.js rendering environment
                renderer = new THREE.WebGLRenderer({ alpha: true })
                renderer.setPixelRatio(window.devicePixelRatio)
                renderer.setSize(window.innerWidth, window.innerHeight)
                renderer.autoClear = false;
                canvas = renderer.domElement;
                document.body.appendChild(canvas)
                scene = new THREE.Scene()
                
                // Creating the ARView, which is the object that handles
                // the rendering of the camera stream behind the three.js
                // scene
                arView = new THREE.ARView(vrDisplay, renderer)
                
                // The ARPerspectiveCamera is very similar to THREE.PerspectiveCamera,
                // except when using an AR-capable browser, the camera uses
                // the projection matrix provided from the device, so that the
                // perspective camera's depth planes and field of view matches
                // the physical camera on the device.
                camera = new THREE.ARPerspectiveCamera(
                        vrDisplay,
                        60,
                        window.innerWidth / window.innerHeight,
                        vrDisplay.depthNear,
                        vrDisplay.depthFar
                )
                
                // VRControls is a utility from three.js that applies the device's
                // orientation/position to the perspective camera, keeping our
                // real world and virtual world in sync.
                vrControls = new THREE.VRControls(camera)
                
                // Bind our event handlers
                window.addEventListener('resize', onWindowResize, false)
                
                // init marker reco
                initMarkerReco()
                
                initLight()
                
                // Kick off the render loop!
                update()
        }
        
        /**
        * The render loop, called once per frame. Handles updating
        * our scene and rendering.
        */
        function update() {

                // Clears color from the frame before rendering the camera (arView) or scene.
                renderer.clearColor()
                
                // Render the device's camera stream on screen first of all.
                // It allows to get the right pose synchronized with the right frame.
                arView.render()

		// call each update function
		onRenderFcts.forEach(function(onRenderFct){
			onRenderFct()
		})
                
                // Update our camera projection matrix in the event that
                // the near or far planes have updated
                camera.updateProjectionMatrix()
                
                // Update our perspective camera's positioning
                vrControls.update()
                
                // If we have not added boxes yet, and we have positional
                // information applied to our camera (it can take a few seconds),
                // and the camera's Y position is not undefined or 0, create boxes
                if (!boxesAdded && !camera.position.y) {
                        addBoxes()
                }
                
                // Render our three.js virtual scene
                renderer.clearDepth()
                renderer.render(scene, camera)

                // Kick off the requestAnimationFrame to call this function
                // when a new VRDisplay frame is rendered
                vrDisplay.requestAnimationFrame(update)
        }
        
        /**
        * On window resize, update the perspective camera's aspect ratio,
        * and call `updateProjectionMatrix` so that we can get the latest
        * projection matrix provided from the device
        */
        function onWindowResize () {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix()
                renderer.setSize(window.innerWidth, window.innerHeight)
        }
        
        /**
        * Once we have position information applied to our camera,
        * create some boxes at the same height as the camera
        */
        function addBoxes () {
                // Create some cubes around the origin point
                for (var i = 0; i < BOX_QUANTITY; i++) {
                        var angle = Math.PI * 2 * (i / BOX_QUANTITY)
                        // var geometry = new THREE.BoxGeometry(1, 1, 1)
                        var geometry = new THREE.TorusGeometry(0.5, 0.1, 32, 16)
                        var material = new THREE.MeshNormalMaterial()
                        var mesh = new THREE.Mesh(geometry, material)
                        mesh.scale.multiplyScalar(BOX_SIZE)
                        mesh.position.set(Math.cos(angle) * BOX_DISTANCE, camera.position.y - 0.25, Math.sin(angle) * BOX_DISTANCE)
                        scene.add(mesh)
                }
                
                // Flip this switch so that we only perform this once
                boxesAdded = true;
        }
</script>
<script>        



        //////////////////////////////////////////////////////////////////////////////
        //                model
        //////////////////////////////////////////////////////////////////////////////
        
        /**
         * to init the lights
         */
        function initLight(){
                // For shadows to work
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                // The materials in Poly models will render as a black mesh
                // without lights in our scenes. Let's add an ambient light
                // so our model can be scene, as well as a directional light
                // for the shadow
                var directionalLight = new THREE.DirectionalLight()
                // @TODO in the future, use AR light estimation
                directionalLight.intensity = 0.3;
                directionalLight.position.set(10, 15, 10)
                // We want this light to cast shadow
                directionalLight.castShadow = true;
                scene.add(directionalLight)                

                var light = new THREE.AmbientLight()
                scene.add(light)                
        }        

        /**
         * load the model - just to make it shinier :)
         */
        function loadModel(originMesh, onLoad){

                // Load model
                THREE.ARUtils.loadModel({
                        objPath: '../vendor/three-ar.js/examples/assets/ArcticFox_Posed.obj',
                        mtlPath: '../vendor/three-ar.js/examples/assets/ArcticFox_Posed.mtl',
                }).then(function(model) {
                        var group = new THREE.Group

                        for(var x = -2; x <= 2; x++){
                                var mesh = model.clone()
                                mesh.position.x = x * 3
                                group.add(mesh)
                        }
                        
                        onLoad && onLoad(group)
                })                
        }
        
        
        //////////////////////////////////////////////////////////////////////////////
        //                Code Separator
        //////////////////////////////////////////////////////////////////////////////

        function initMarkerReco(){
                //////////////////////////////////////////////////////////////////////////////
                //                init originMesh
                //////////////////////////////////////////////////////////////////////////////
                var originMesh = new THREE.Group
                scene.add(originMesh)
                
                var geometry = new THREE.BoxGeometry(1, 1, 1)
                var material = new THREE.MeshNormalMaterial({
                        wireframe: true
                })
                var cube = new THREE.Mesh(geometry, material)
                cube.scale.multiplyScalar(0.08)
                // cube.position.z = geometry.parameters.height * cube.scale.z / 2
                originMesh.add(cube)
                
                var axisHelper = new THREE.AxisHelper
                axisHelper.scale.multiplyScalar(0.08)
                // axisHelper.rotation.x = -Math.PI/2
                originMesh.add(axisHelper)

                
                // loadModel(originMesh, function onLoad(model){
                //         model.scale.multiplyScalar(0.08)
                //         originMesh.add( model )                    
                // })

        	////////////////////////////////////////////////////////////////////////////////
        	//          handle arToolkitSource
        	////////////////////////////////////////////////////////////////////////////////

        	var arToolkitSource = new THREEx.ArToolkitSource({
        		// to read from the webcam 
        		sourceType : 'canvas',
                        sourceCanvas: renderer.domElement,
        	})

        	arToolkitSource.init(function onReady(){
        		// onResize()
        	})

        	// // handle resize
        	// window.addEventListener('resize', function(){
        	// 	onResize()
        	// })
        	// function onResize(){
        	// 	arToolkitSource.onResizeElement()	
        	// 	arToolkitSource.copyElementSizeTo(renderer.domElement)	
        	// 	if( arToolkitContext.arController !== null ){
        	// 		arToolkitSource.copyElementSizeTo(arToolkitContext.arController.canvas)	
        	// 	}	
        	// }

        	////////////////////////////////////////////////////////////////////////////////
        	//          initialize arToolkitContext
        	////////////////////////////////////////////////////////////////////////////////	
        	////////////////////////////////////////////////////////////////////////////////	

        	// create atToolkitContext
        	var arToolkitContext = new THREEx.ArToolkitContext({
        		cameraParametersUrl: THREEx.ArToolkitContext.baseURL + '../data/data/camera_para.dat',
        		detectionMode: 'mono',

        		// canvasWidth: 80*3,
        		// canvasHeight: 60*3,
        		// canvasWidth: Math.floor(1442/10),
        		// canvasHeight: Math.floor(2226/10),

        		canvasWidth: Math.floor(renderer.domElement.width/5),
        		canvasHeight: Math.floor(renderer.domElement.height/5),

        		maxDetectionRate: 30,
        	})

window.arToolkitContext = arToolkitContext

        	// initialize it
        	arToolkitContext.init(function onCompleted(){
        	// 	// copy projection matrix to camera
        		// camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() )

                        // display the pure ar.js world
                        var debugRenderer = new ThreejsDebugRenderer(arToolkitContext)
                        onRenderFcts.push(function(){
                                debugRenderer.update(markerRoot)
                        })

        	})

        	// update artoolkit on every frame
        	onRenderFcts.push(function(){
        		if( arToolkitSource.ready === false )	return

        		arToolkitContext.update( arToolkitSource.domElement )
        	})

        	////////////////////////////////////////////////////////////////////////////////
        	//          Create a ArMarkerControls
        	////////////////////////////////////////////////////////////////////////////////
        	
        	var markerRoot = new THREE.Group
        	// scene.add(markerRoot)
        	var markerControls = new THREEx.ArMarkerControls(arToolkitContext, markerRoot, {
        		// size: 0.08,   // for a 8cm square marker
        		
        		type : 'pattern',
        		patternUrl : THREEx.ArToolkitContext.baseURL + 'examples/marker-training/examples/pattern-files/pattern-hiro.patt',
        	})

                // onRenderFcts.push(function(){
                //         console.log('camera.position', camera.position.x.toFixed(2))
                // })

                onRenderFcts.push(function(){
                        displayInfoDebug()
                })
                
                function displayInfoDebug(){
                        // console.log('camera.position', camera.position)
                        var domElement = document.querySelector('#info .markerroot_status')
                        // update the marker status for debug
                        if( markerRoot.visible === true ){
                                // console.log('markerRoot.position', markerRoot.position)
                                domElement.innerHTML = markerRoot.position.x.toFixed(2) + ' '
                                                        + markerRoot.position.y.toFixed(2) + ' '
                                                        + markerRoot.position.z.toFixed(2)
                        }else{
                                domElement.innerHTML = '<span style="color:red">invisible</span>'                                
                        }
                }
                
                document.body.addEventListener('click', function(){
                        // resyncVRFrameDataCameraOrigin()
                        resyncMarkerPositionQuaternion()
                })

                // resync at everyframe from debug
                onRenderFcts.push(function(){
                        resyncMarkerPositionQuaternion()
                })
                
                function resyncVRFrameDataCameraOrigin(){

                        // Fetch the pose data from the current frame
                        vrDisplay.getFrameData(vrFrameData)
                        var pose = vrFrameData.pose;

                        // Convert the pose orientation and position into
                        // THREE.Quaternion and THREE.Vector3 respectively
                        var quaternion = new THREE.Quaternion(
                                pose.orientation[0],
                                pose.orientation[1],
                                pose.orientation[2],
                                pose.orientation[3]
                        )

                        var position = new THREE.Vector3(
                                pose.position[0],
                                pose.position[1],
                                pose.position[2]
                        )

                        // put it in front of the camera
                        // var rotationMatrix = new THREE.Matrix4()
                        // rotationMatrix.makeRotationFromQuaternion(quaternion)
                        // 
                        // var push = new THREE.Vector3(0, 0, -1.0)
                        // push.transformDirection(rotationMatrix)
                        // position.addScaledVector(push, 0.2)

                        originMesh.position.copy(position)
                        originMesh.quaternion.copy(quaternion)
                }

                function resyncMarkerPositionQuaternion(){
                        if( markerRoot.visible !== true ){
                                originMesh.visible = false
                                return                                
                        }
                        originMesh.visible = true

                        var quaternion = new THREE.Quaternion
                	// var projectionAxisTransformMatrix = new THREE.Matrix4()
                	// projectionAxisTransformMatrix.multiply(new THREE.Matrix4().makeRotationY(Math.PI))
                	// projectionAxisTransformMatrix.multiply(new THREE.Matrix4().makeRotationZ(Math.PI))

                        var camRotationMatrix = new THREE.Matrix4().extractRotation(camera.matrix)
                        var matrix = new THREE.Matrix4
                        // matrix.multiply(new THREE.Matrix4().makeRotationFromQuaternion(markerRoot.quaternion))
                        matrix.multiply(camRotationMatrix)
                	// matrix.multiply(new THREE.Matrix4().makeRotationX(-Math.PI/2))
                	matrix.decompose(new THREE.Vector3, quaternion, new THREE.Vector3)

                        // init the position to the camera position
                        var position = new THREE.Vector3()
                        position.copy(camera.position)
                        
                        // add the marker position to this position
                        var vector3 = markerRoot.position.clone().multiplyScalar(0.1)   // FIXME why 0.1 ??
                        var rotationMatrix = new THREE.Matrix4().makeRotationFromQuaternion(camera.quaternion)
                        vector3.applyMatrix4(rotationMatrix)
                        position.add(vector3)

                        // copy position/quaternion into originMesh
                        originMesh.position.copy(position)
                        originMesh.quaternion.copy(quaternion)
                }
        }


        //////////////////////////////////////////////////////////////////////////////
        //                to display a 3d scene with only ar.js - for debug only
        //////////////////////////////////////////////////////////////////////////////
        function ThreejsDebugRenderer( arToolkitContext ){
        	// init renderer
        	var renderer	= new THREE.WebGLRenderer({
        		antialias: true,
        		alpha: true
        	})
        	renderer.setSize( window.innerWidth, window.innerHeight )
        	renderer.domElement.style.position = 'absolute'
        	renderer.domElement.style.top = '0px'
        	renderer.domElement.style.left = '0px'
        	document.body.appendChild( renderer.domElement )

        	// array of functions for the rendering loop
        	var onRenderFcts= [];

        	// init scene and camera
        	var scene	= new THREE.Scene()

        	// Create a camera
        	var camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.01, 100 )
                
        	camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() )

        	//////////////////////////////////////////////////////////////////////////////////
        	//		add an object in the scene
        	//////////////////////////////////////////////////////////////////////////////////

                var markerRoot = new THREE.Group
                scene.add(markerRoot)

                var axisHelper = new THREE.AxisHelper
                markerRoot.add(axisHelper)

        	// add a torus knot	
        	var geometry	= new THREE.CubeGeometry(1,1,1)
        	var material	= new THREE.MeshNormalMaterial({
        		transparent : true,
        		opacity: 0.5,
        		side: THREE.DoubleSide
        	})
        	var meshCube	= new THREE.Mesh( geometry, material )
                meshCube.position.y += 0.5
        	markerRoot.add( meshCube )

        	var geometry	= new THREE.TorusKnotGeometry(0.3,0.1,64,16)
        	var material	= new THREE.MeshNormalMaterial() 
        	var meshTorus	= new THREE.Mesh( geometry, material )
                meshTorus.position.y += 0.5
        	markerRoot.add( meshTorus )

                this.update = function(sourceMarkerObject3d){
                        // copy sourceMarkerObject3d in markerRoot
                        markerRoot.matrix.copy(sourceMarkerObject3d.matrix)
        		markerRoot.matrix.decompose(markerRoot.position, markerRoot.quaternion, markerRoot.scale)

                        // animate local object
        		meshTorus.rotation.x += Math.PI*0.1
                        
                        // render scene
        		renderer.render( scene, camera )
                }
        }



</script>
</body>
</html>
